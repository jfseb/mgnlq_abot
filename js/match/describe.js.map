{"version":3,"sources":["/projects/nodejs/botbuilder/fdevstart/src/../src/match/describe.ts"],"names":[],"mappings":"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","file":"match/describe.js","sourcesContent":["/**\n *\n * @module jfseb.fdevstart.explain\n * @file explain.ts\n * @copyright (c) 2016 Gerd Forstmann\n *\n * Functions dealing with explaining facts, categories etc.\n */\n\n\nimport * as Algol from './algol';\nimport * as debug from 'debugf';\n\nconst debuglog = debug('describe');\nimport * as logger from '../utils/logger';\nvar logPerf = logger.perf(\"perflistall\");\nvar perflog = debug('perf');\n//const perflog = logger.perf(\"perflistall\");\n\n\n//import * as Toolmatcher from './toolmatcher';\n\nimport { Sentence as Sentence } from 'mgnlq_er';\n\nimport { Word as Word } from 'mgnlq_er';\nimport * as Operator from './operator';\n\nimport * as WhatIs from './whatis';\n\nimport * as IMatch from './ifmatch';\nimport { Model, IFModel, BreakDown } from 'mgnlq_model';\n\n\nimport * as Match from './match';\n\n\nimport * as Utils from 'abot_utils';\n\n\nvar sWords = {};\n\nexport function isSynonymFor(exactWord : string, sloppyWord : string, theModel: IMatch.IModels) : boolean {\n  // TODO: use model synonyms\n  return sloppyWord === \"name\" && exactWord === \"element name\";\n}\n\nexport function sloppyOrExact(exactWord : string, sloppyWord : string, theModel: IMatch.IModels) {\n  if(exactWord.toLowerCase() === sloppyWord.toLowerCase()) {\n    return '\"' + sloppyWord + '\"';\n  }\n  // TODO, find plural s etc.\n  // still exact,\n  //\n  if(isSynonymFor(exactWord,sloppyWord,theModel)) {\nreturn '\"' + sloppyWord + '\" (interpreted as synonym for \"' + exactWord +'\")';\n  }\n  //todo, find is synonymfor ...\n  // TODO, a synonym for ...\n  return '\"' + sloppyWord + '\" (interpreted as \"' + exactWord +'\")';\n}\n\ninterface IDescribeCategory {\n    totalrecords : number,\n    presentrecords : number,\n    values : { [key : string] : number},\n    multivalued : boolean\n  }\n/*\nexport function countRecordPresenceOLD(category : string, domain : string, theModel : IMatch.IModels) : IDescribeCategory {\n  var res = { totalrecords : 0,\n    presentrecords : 0,\n    values : { },  // an their frequency\n    multivalued : false\n  } as IDescribeCategory;\n  theModel.records.forEach(function(record) {\n    //debuglog(JSON.stringify(record,undefined,2));\n    if(record._domain !== domain) {\n      return;\n    }\n    res.totalrecords++;\n    var val = record[category];\n    var valarr = [val];\n    if(Array.isArray(val)) {\n      res.multivalued = true;\n      valarr = val;\n    }\n    // todo wrap arr\n    if(val !== undefined && val !== \"n/a\") {\n      res.presentrecords ++;\n    }\n    valarr.forEach(function(val) {\n      res.values[val] = (res.values[val] || 0) + 1;\n    })\n  })\n  return res;\n}\n*/\n\nexport function countRecordPresence(category : string, domain : string, theModel : IMatch.IModels) : Promise<IDescribeCategory> {\n  var res = { totalrecords : 0,\n    presentrecords : 0,\n    values : { }, // [key : string] : number },  // and their frequency\n    multivalued : false\n  } as IDescribeCategory;\n\n  return Model.getExpandedRecordsForCategory(theModel,domain,category).then(records =>{\n      res.totalrecords = records.length;\n      records.forEach(function(record) {\n        //debuglog(JSON.stringify(record,undefined,2));\n        /*if(record._domain !== domain) {\n          return;\n        }*/\n        var val = record[category];\n        var valarr = [val];\n        if(Array.isArray(val)) {\n          res.multivalued = true;\n          valarr = val;\n        }\n        // todo wrap arr\n        if(val !== undefined && val !== \"n/a\") {\n          res.presentrecords ++;\n        }\n        valarr.forEach(function(val) {\n          res.values[val] = (res.values[val] || 0) + 1;\n        })\n      });\n    }).then( () => res );\n}\n\ninterface IDescribeFact {\n    totalrecords : number,\n    presentrecords : number,\n    multivalued : boolean\n  }\n\n/*\nexport function countRecordPresenceFact(fact : string, category : string, domain : string, theModel : IMatch.IModels) : Promise<IDescribeFact> {\n  var res = { totalrecords : 0,\n    presentrecords : 0,\n    values : { },  // an their frequency\n    multivalued : false\n  } as IDescribeCategory;\n  return Model.getExpandedRecordsForCategory(theModel,domain,category).then(records =>{\n    res.totalrecords = records.length;\n    records.forEach((record) =>{\n      res.totalrecords++;\n      var val = record[category];\n      var valarr = [val];\n      if(Array.isArray(val)) {\n        if(val.indexOf(fact) >= 0) {\n          res.multivalued = true;\n          valarr = val;\n          res.presentrecords++;\n        }\n      } else if (val === fact) {\n          res.presentrecords++;\n      }\n    });\n    return res;\n  });\n}\n*/\n\n/*\nexport function countRecordPresenceFactOld(fact : string, category : string, domain : string, theModel : IMatch.IModels) : IDescribeFact {\n  var res = { totalrecords : 0,\n    presentrecords : 0,\n    values : { },  // an their frequency\n    multivalued : false\n  } as IDescribeCategory;\n\n\n  theModel.records.forEach(function(record) {\n    //debuglog(JSON.stringify(record,undefined,2));\n    if(record._domain !== domain) {\n      return;\n    }\n    res.totalrecords++;\n    var val = record[category];\n    var valarr = [val];\n    if(Array.isArray(val)) {\n      if(val.indexOf(fact) >= 0) {\n        res.multivalued = true;\n        valarr = val;\n        res.presentrecords++;\n      }\n    } else if (val === fact) {\n        res.presentrecords++;\n    }\n  })\n  return res;\n}\n*/\n\nexport function makeValuesListString(realvalues: string[]) : string {\n  var valuesString = \"\";\n  var totallen = 0;\n  var listValues = realvalues.filter(function(val, index) {\n    totallen = totallen + val.length;\n  return (index < Algol.DescribeValueListMinCountValueList) || (totallen < Algol.DescribeValueListLengthCharLimit);\n  });\n  if(listValues.length === 1 && realvalues.length === 1) {\n    return 'The sole value is \\\"' + listValues[0] + '\"';\n  }\n  var maxlen = listValues.reduce( (prev,val) => Math.max(prev,val.length),0);\n  if(maxlen > 30) {\n    return \"Possible values are ...\\n\" +\n      listValues.reduce( (prev,val,index) => (prev + \"(\" + (index + 1) + '): \"' + val + '\"\\n'\n      ),\"\")\n      + ( listValues.length === realvalues.length ? \"\" : \"...\");\n  }\n  var list = \"\";\n  if(listValues.length === realvalues.length) {\n    list = Utils.listToQuotedCommaOr(listValues);\n  } else {\n    list = '\"' + listValues.join('\", \"') + '\"';\n  }\n  return \"Possible values are ...\\n\"\n    + list\n    + ( listValues.length === realvalues.length ? \"\" : \" ...\");\n}\n\nexport function toPercent(a : number, b: number) : string {\n  return \"\" + (100* a / b).toFixed(1);\n}\n\n\nexport interface ICategoryStats {\n  categoryDesc : IFModel.ICategoryDesc,\n  presentRecords : number,\n  distinct : string,\n  delta : string,\n  percPresent : string,\n  sampleValues : string,\n};\n\nexport function getCategoryStatsInDomain(category : string, filterdomain : string, theModel: IMatch.IModels) : Promise<ICategoryStats> {\n  return countRecordPresence(category, filterdomain, theModel).then(\n    (recordCount) => {\n      //debuglog(JSON.stringify(theModel.records.filter(a => a._domain === \"Cosmos\"),undefined,2));\n      const percent = toPercent(recordCount.presentrecords , recordCount.totalrecords);\n      debuglog(JSON.stringify(recordCount.values));\n      var allValues =Object.keys(recordCount.values);\n      var realvalues = allValues.filter(value => (value !== 'undefined') && (value !== 'n/a'));\n      debuglog\n      realvalues.sort();\n      var undefNaDelta =  (allValues.length - realvalues.length);\n      var delta =  (undefNaDelta) ?  \"(+\" + undefNaDelta + \")\" : \"\";\n      const distinct = '' + realvalues.length;\n      const valuesList = makeValuesListString(realvalues);\n      return {\n        categoryDesc : theModel.full.domain[filterdomain].categories[category],\n        distinct : distinct,\n        delta : delta,\n        presentRecords : recordCount.presentrecords,\n        percPresent : percent,\n        sampleValues : valuesList\n      };\n    }\n  );\n}\n\nexport function describeCategoryInDomain(category : string, filterdomain : string, theModel: IMatch.IModels) : Promise<string> {\n/*  const recordCount = countRecordPresence(category, filterdomain, theModel);\n  debuglog(JSON.stringify(theModel.records.filter(a => a._domain === \"Cosmos\"),undefined,2));\n  const percent = toPercent(recordCount.presentrecords , recordCount.totalrecords);\n  debuglog(JSON.stringify(recordCount.values));\n  var allValues =Object.keys(recordCount.values);\n  var realvalues = allValues.filter(value => (value !== 'undefined') && (value !== 'n/a'));\n  debuglog\n  realvalues.sort();\n  var undefNaDelta =  (allValues.length - realvalues.length);\n  var delta =  (undefNaDelta) ?  \"(+\" + undefNaDelta + \")\" : \"\";\n  const distinct = '' + realvalues.length;\n\n  const valuesList = makeValuesListString(realvalues);\n*/\n  return getCategoryStatsInDomain(category,filterdomain,theModel).then( (stats) => {\n    var res = 'is a category in domain \"' + filterdomain + '\"\\n'\n    + `It is present in ${stats.presentRecords} (${stats.percPresent}%) of records in this domain,\\n` +\n    `having ${stats.distinct + ''}${stats.delta} distinct values.\\n`\n    + stats.sampleValues;\n\n    var desc = theModel.full.domain[filterdomain].categories[category] || {} as IFModel.ICategoryDesc;\n    var description = desc.category_description || \"\";\n    if (description) {\n      res += `\\nDescription: ${description}`;\n    }\n    return res;\n  });\n}\n\nexport function findRecordsWithFact(matchedString: string, category : string, records : any, domains : { [key : string] : number}) : any[] {\n  return records.filter(function(record)  {\n\n    let res = (record[category] === matchedString);\n    if( res) {\n      increment(domains,records._domain);\n    }\n    return res;\n  });\n}\n\nexport function increment(map : {[key: string] : number}, key : string) {\n  map[key] = (map[key] || 0) + 1;\n}\n\nfunction sortedKeys<T>(map : {[key : string] : T}) : string[] {\n  var r = Object.keys(map);\n  r.sort();\n  return r;\n}\n\nexport function describeDomain(fact : string, domain: string, theModel: IMatch.IModels) : Promise<string> {\n\n  return Model.getExpandedRecordsForCategory(theModel,domain, Model.getCategoriesForDomain(theModel,domain)[0]).then(\n    (records) =>{\n    var count = records.length;\n    var catcount = Model.getCategoriesForDomain(theModel, domain).length;\n    var res = sloppyOrExact(domain, fact, theModel) + `is a domain with ${catcount} categories and ${count} records\\n`;\n    var desc = theModel.full.domain[domain].description || \"\";\n    if(desc) {\n      res += `Description:` + desc + `\\n`;\n    }\n    return res;\n  });\n}\n/*\nexport function describeFactInDomainOld(fact : string, filterdomain : string, theModel: IMatch.IModels) : string {\n  var sentences = WhatIs.analyzeContextString(fact,  theModel.rules);\n  //console.log(\"here sentences \" + JSON.stringify(sentences));\n  var lengthOneSentences = sentences.sentences.filter(oSentence => oSentence.length === 1);\n  var res = '';\n  // remove categories and domains\n  var onlyFacts = lengthOneSentences.filter(oSentence =>{\n    debuglog(JSON.stringify(oSentence[0]));\n    return !Word.Word.isDomain(oSentence[0]) &&\n           !Word.Word.isFiller(oSentence[0]) && !Word.Word.isCategory(oSentence[0])\n  }\n  );\n  var onlyDomains = lengthOneSentences.filter(oSentence =>{\n    return Word.Word.isDomain(oSentence[0]);\n  });\n  if(onlyDomains && onlyDomains.length > 0) {\n    debuglog(()=>JSON.stringify(onlyDomains));\n    onlyDomains.forEach(function(sentence) {\n      var domain = sentence[0].matchedString;\n      if( !filterdomain || domain === filterdomain) {\n        debuglog(()=>\"here match \" + JSON.stringify(sentence));\n        res += describeDomain(fact, sentence[0].matchedString, theModel);\n      }\n    })\n  }\n\n  debuglog(\"only facts: \" + JSON.stringify(onlyFacts));\n  var recordMap = {};\n  var domainsMap = {} as {[key: string] : number};\n  var matchedwordMap = {} as {[key: string] : number};\n  var matchedCategoryMap = {} as {[key: string] : number};\n  // look for all records\n  onlyFacts.forEach(oSentence =>\n    oSentence.forEach(oWord =>\n      {\n        increment(matchedwordMap, oWord.matchedString);\n        increment(matchedCategoryMap, oWord.category);\n      }\n    )\n  );\n  // we have:\n  // a list of categories,\n  // a list of matchedWords  ->\n  //\n\n  var categories = sortedKeys(matchedCategoryMap);\n  var matchedwords = sortedKeys(matchedwordMap);\n  debuglog(()=>\"matchedwords: \" + JSON.stringify(matchedwords));\n  debuglog(()=>\"categories: \" + JSON.stringify(categories));\n\n  //var allMatchedWords = { [key : string] : number };\n  var domainRecordCount = {} as {[key: string] : number};\n  var domainMatchCatCount = {} as {[key: string] :\n       {[key: string] :\n     {[key: string] : number}}};\n  // we prepare the following structure\n  //\n  // {domain} : recordcount;\n  // {matchedwords} :\n  // {domain} {matchedword} {category} presencecount\n  theModel.records.forEach(function(record) {\n    if(!filterdomain || record._domain === filterdomain ) {\n      domainRecordCount[record._domain] = (domainRecordCount[record._domain] || 0) + 1;\n      matchedwords.forEach(matchedword =>\n        categories.forEach(category => {\n          if( record[category] === matchedword) {\n            var md = domainMatchCatCount[record._domain] = domainMatchCatCount[record._domain] || {};\n            var mdc = md[matchedword] =  md[matchedword] || {};\n            increment(mdc,category);\n          };\n        }\n        )\n      );\n    }\n  });\n  debuglog(()=>JSON.stringify(domainMatchCatCount,undefined,2));\n  debuglog(()=>JSON.stringify(domainRecordCount,undefined,2));\n  var domains = sortedKeys(domainMatchCatCount);\n  var resNext =  '\"' + fact + '\" has a meaning in ';\n  var single = false;\n  if(Object.keys(domainMatchCatCount).length > 1) {\n    resNext += '' + domains.length +\n              ' domains: ' + Utils.listToQuotedCommaAnd(domains) + \"\";\n  } else if(domains.length === 1) {\n    if(!filterdomain) {\n      resNext += `one `;\n    }\n    resNext += `domain \"${domains[0]}\":`;\n    single = true;\n  } else {\n    if(res) {\n      return res;\n    }\n    var factclean = Utils.stripQuotes(fact);\n    if(filterdomain) {\n      return `\"${factclean}\" is no known fact in domain \"${filterdomain}\".\\n`;\n    }\n    return `I don't know anything about \"${factclean}\".\\n`;\n  }\n  res += resNext + \"\\n\"; // ...\\n\";\n  domains.forEach(function(domain) {\n    var md = domainMatchCatCount[domain];\n    Object.keys(md).forEach(matchedstring => {\n      var mdc = md[matchedstring];\n      if(!single) {\n        res += 'in domain \"' + domain + '\" ';\n      }\n      var catsingle = Object.keys(mdc).length === 1;\n      res += `${sloppyOrExact(matchedstring,fact,theModel)} `;\n      if(!catsingle) {\n        res += `...\\n`;\n      }\n      Object.keys(mdc).forEach(category => {\n      var percent =  toPercent(mdc[category],domainRecordCount[domain]);\n        res += `is a value for category \"${category}\" present in ${mdc[category]}(${percent}%) of records;\\n`;\n      });\n    });\n  });\n  return res;\n}\n*/\n\nexport function describeFactInDomain(fact : string, filterdomain : string, theModel: IMatch.IModels) : Promise<string> {\n  var sentences = WhatIs.analyzeContextString(fact,  theModel.rules);\n  //console.log(\"here sentences \" + JSON.stringify(sentences));\n  var lengthOneSentences = sentences.sentences.filter(oSentence => oSentence.length === 1);\n  var res = '';\n  // remove categories and domains\n  var onlyFacts = lengthOneSentences.filter(oSentence =>{\n    debuglog(JSON.stringify(oSentence[0]));\n    return !Word.Word.isDomain(oSentence[0]) &&\n           !Word.Word.isFiller(oSentence[0]) && !Word.Word.isCategory(oSentence[0])\n  });\n  var onlyDomains = lengthOneSentences.filter(oSentence =>{\n    return (Word.Word.isDomain(oSentence[0]));\n  });\n  var pPromise = undefined;\n  debuglog(()=> ` here onlyDomains ${onlyDomains.join(';')}`);\n  if(onlyDomains && onlyDomains.length > 0) {\n    debuglog(()=>JSON.stringify(onlyDomains));\n    pPromise = (global.Promise as any).all(onlyDomains.map(function(sentence) {\n      var domain = sentence[0].matchedString;\n      if( !filterdomain || (domain === filterdomain)) {\n        debuglog(()=>\"here match \" + JSON.stringify(sentence));\n        return describeDomain(fact, sentence[0].matchedString, theModel).then(\n          rx => {\n            //console.log(`described domain ${fact} ${domain} ` + rx);\n            res += rx\n          }\n        );\n      } else {\n        return (global.Promise as any).resolve(undefined);\n      }\n    })).then( (arr) => {\n      debuglog( ()=> arr.join(\";\"));\n      arr.map( (rec) => {\n        if(rec !== undefined) {\n          res += rec;\n        }\n      });\n      return res;\n    });\n  } else {\n    pPromise = (global.Promise as any).resolve(res);\n  };\n  return pPromise.then(resu => {\n    debuglog(()=> `constructed so far \"${res}\"`);\n    debuglog(\"only facts: \" + JSON.stringify(onlyFacts));\n    var recordMap = {};\n    var domainsMap = {} as {[key: string] : number};\n    var matchedwordMap = {} as {[key: string] : number};\n    var matchedCategoryMap = {} as {[key: string] : number};\n    // look for all records\n    onlyFacts.forEach(oSentence =>\n      oSentence.forEach(oWord =>\n        {\n          increment(matchedwordMap, oWord.matchedString);\n          increment(matchedCategoryMap, oWord.category);\n        }\n      )\n    );\n    // we have:\n    // a list of categories,\n    // a list of matchedWords  ->\n    //\n    var categories = sortedKeys(matchedCategoryMap);\n    categories.sort();\n    var matchedwords = sortedKeys(matchedwordMap);\n    debuglog(()=>\"matchedwords: \" + JSON.stringify(matchedwords));\n    debuglog(()=>\"categories: \" + JSON.stringify(categories));\n\n    //var allMatchedWords = { [key : string] : number };\n    var domainRecordCount = {} as {[key: string] : number};\n    var domainMatchCatCount = {} as {[key: string] :\n      {[key: string] :\n      {[key: string] : number}}\n    };\n\n    var filteredDomains = theModel.domains.filter( (domain) =>\n      ((!filterdomain) || domain === filterdomain)\n    );\n\n    // we prepare the following structure\n    //\n    // {domain} : recordcount;\n    // {matchedwords} :\n    // {domain} {matchedword} {category} presencecount\n    return (global.Promise as any).all(\n      filteredDomains.map( (domain) => {\n        if(!filterdomain || domain === filterdomain ) {\n          return Model.getExpandedRecordsFull(theModel, domain).then(records => {\n            domainRecordCount[domain] = records.length;\n            records.map( (record) =>{\n      // domainRecordCount[record._domain] = (domainRecordCount[record._domain] || 0) + 1;\n              matchedwords.forEach(matchedword =>{\n                categories.forEach(category => {\n                if(record[category] === matchedword) {\n                  var md = domainMatchCatCount[domain] = domainMatchCatCount[domain] || {};\n                  var mdc = md[matchedword] =  md[matchedword] || {};\n                  increment(mdc,category);\n                }\n              });\n              });\n            });\n          });\n        } else {\n          return Model.getExpandedRecordsFull(theModel, domain).then(records => {\n            domainRecordCount[domain] = records.length;\n            records.map( (record) =>{\n      // domainRecordCount[record._domain] = (domainRecordCount[record._domain] || 0) + 1;\n              matchedwords.forEach(matchedword =>{\n                categories.forEach(category => {\n                if(record[category] === matchedword) {\n                  var md = domainMatchCatCount[domain] = domainMatchCatCount[domain] || {};\n                  var mdc = md[matchedword] =  md[matchedword] || {};\n                  increment(mdc,category);\n                }\n              });\n              });\n            });\n          });\n        }\n      })\n    ).then( (a) => {\n      debuglog(()=> 'terminal processing ' + res);\n      debuglog(()=>JSON.stringify(domainMatchCatCount,undefined,2));\n      debuglog(()=>JSON.stringify(domainRecordCount,undefined,2));\n      var domains = sortedKeys(domainMatchCatCount);\n      var resNext =  '\"' + fact + '\" has a meaning in ';\n      var single = false;\n      if(Object.keys(domainMatchCatCount).length > 1) {\n        resNext += '' + domains.length +\n                  ' domains: ' + Utils.listToQuotedCommaAnd(domains) + \"\";\n      } else if(domains.length === 1) {\n        if(!filterdomain) {\n          resNext += `one `;\n        }\n        resNext += `domain \"${domains[0]}\":`;\n        single = true;\n      } else {\n        if(res) {\n          return res;\n        }\n        var factclean = Utils.stripQuotes(fact);\n        if(filterdomain) {\n          return `\"${factclean}\" is no known fact in domain \"${filterdomain}\".\\n`;\n        }\n        return `I don't know anything about \"${factclean}\".\\n`;\n      }\n      res += resNext + \"\\n\"; // ...\\n\";\n      domains.forEach(function(domain) {\n        var md = domainMatchCatCount[domain];\n        Object.keys(md).forEach(matchedstring => {\n          var mdc = md[matchedstring];\n          if(!single) {\n            res += 'in domain \"' + domain + '\" ';\n          }\n          var catsingle = Object.keys(mdc).length === 1;\n          res += `${sloppyOrExact(matchedstring,fact,theModel)} `;\n          if(!catsingle) {\n            res += `...\\n`;\n          }\n          Object.keys(mdc).forEach(category => {\n            debuglog( ()=>` percent : ${mdc[category]} of ${domainRecordCount[domain]} `);\n          var percent =  toPercent(mdc[category],domainRecordCount[domain]);\n            res += `is a value for category \"${category}\" present in ${mdc[category]}(${percent}%) of records;\\n`;\n          });\n        });\n      });\n      return res;\n    });\n  });\n\n}\n\n\nexport function describeCategory(category : string, filterDomain: string, model: IMatch.IModels,message : string) : Promise<string[]> {\n  var doms = Model.getDomainsForCategory(model,category);\n  function getPromiseArr() {\n    var res = [];\n\n    if(filterDomain) {\n      if(doms.indexOf(filterDomain) >= 0) {\n        res.push(describeCategoryInDomain(category,filterDomain,model));\n        return res;\n      } else {\n        return [];\n      }\n    }\n    doms.sort();\n    doms.forEach(function(domain) {\n          res.push(describeCategoryInDomain(category, domain, model));\n    });\n    return res;\n    }\n    var resPromiseArr = getPromiseArr();\n    return (global.Promise as any).all(resPromiseArr).then( (resArr) => resArr);\n}\n"],"sourceRoot":"ABC"}