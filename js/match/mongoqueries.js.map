{"version":3,"sources":["/projects/nodejs/botbuilder/mgnlq_abot/src/../src/match/mongoqueries.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;AAGH,gCAAgC;AAEhC,MAAM,QAAQ,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC;AACvC,0CAA0C;AAC1C,IAAI,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;AAC1C,IAAI,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;AAe5B,6CAAoC;AACpC,iDAAiD;AAEjD,IAAI,MAAM,GAAG,EAAE,CAAC;AAEhB,uBAAuB;AACvB,+BAA+B;AAC/B,mCAAmC;AAEnC,SAAgB,OAAO,CAAC,KAAa,EAAE,QAAwB;IAC7D,OAAO,sBAAM,CAAC,KAAK,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,IAAI,CACvC,GAAG,CAAC,EAAE;QACJ,QAAQ,CAAC,GAAG,EAAE,CAAC,oBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;QACzE,OAAO,GAAG,CAAC;IACb,CAAC,CACF,CAAC;AACJ,CAAC;AAPD,0BAOC;AACK;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BH;AACH,SAAgB,UAAU,CAAC,KAAa,EAAE,QAAwB;IAChE,yBAAyB;IACzB,wCAAwC;IACxC,EAAE;IACF,OAAO,sBAAM,CAAC,YAAY,CAAC,KAAK,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC,IAAI,CAClD,GAAG,CAAC,EAAE;QACJ,QAAQ,CAAC,GAAG,EAAE,CAAC,oBAAoB,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;QACzE,yBAAyB;QACzB,IAAI,OAAO,GAAG,SAAS,CAAC;QACxB,GAAG,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,KAAK,EAAE,EAAE;YACxB,IAAI,MAAM,GAAG,EAAE,CAAC,MAAM,CAAC;YACvB,IAAI,CAAC,OAAO,IAAI,EAAE,CAAC,OAAO,CAAC,MAAM,IAAI,MAAM,EAAE;gBAC3C,IAAI,aAAa,GAAG,mBAAK,CAAC,6BAA6B,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;gBAC1E,IAAI,WAAW,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;gBACnC,kDAAkD;gBAClD,IAAI,WAAW;oBACX,CAAC,CAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;2BACrC,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAC7C;oBACA,yDAAyD;oBACzD,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;wBACvB,QAAQ,CAAC,GAAE,EAAE,CAAC,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;wBACjD,IAAI,CAAC,OAAO,IAAI,GAAG,CAAC,WAAW,CAAC,EAAE;4BAChC,OAAO,GAAG,GAAG,CAAC,WAAW,CAAC,CAAC;yBAC5B;oBACH,CAAC,CAAC,CAAC;iBACJ;aACF;QACH,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC,CAAC;IAClD,CAAC,CACF,CAAC;AACJ,CAAC;AAhCD,gCAgCC","file":"mongoqueries.js","sourcesContent":["/**\n *\n * @module jfseb.fdevstart.analyze\n * @file analyze.ts\n * @copyright (c) 2016 Gerd Forstmann\n */\n\n\nimport * as debug from 'debugf';\n\nconst debuglog = debug('mongoqueries');\nimport * as logger from '../utils/logger';\nvar logPerf = logger.perf(\"mongoqueries\");\nvar perflog = debug('perf');\n//const perflog = logger.perf(\"perflistall\");\n\nimport * as Utils from 'abot_utils';\nimport * as _ from 'lodash';\nimport * as IMatch from './ifmatch';\n\nimport { BreakDown } from 'mgnlq_model';\n\nimport { Sentence as Sentence } from 'mgnlq_parser1';\n\nimport { Word as Word } from 'mgnlq_parser1';\nimport * as Operator from './operator';\nimport * as WhatIs from './whatis';\nimport { ErError as ErError } from 'mgnlq_parser1';\nimport { Model } from 'mgnlq_model';\nimport { MongoQ as MongoQ } from 'mgnlq_parser1';\n\nvar sWords = {};\n\n/* we have sentences */\n/* sentences lead to queries */\n/* queries have columns, results */\n\nexport function listAll(query: string, theModel: IMatch.IModels): Promise<MongoQ.IProcessedMongoAnswers> {\n  return MongoQ.query(query, theModel).then(\n    res => {\n      debuglog(() => 'got a query result' + JSON.stringify(res, undefined, 2));\n      return res;\n    }\n  );\n}\n      /*\n      var tupelanswers = [] as IMatch.IWhatIsTupelAnswer[];\n      res.queryresults.map((qr, index) => {\n        qr.results.forEach(function (result) {\n          tupelanswers.push({\n            record: {},\n            categories: qr.columns,\n            sentence: qr.sentence,\n            result: result,\n            _ranking: 1.0 // res.sentences[index]._ranking\n          });\n        });\n      });\n      return {\n        tupelanswers: tupelanswers,\n        errors: res.errors,\n        tokens: res.tokens\n      }\n    }\n  )\n}\n\n/**\n * Query for a showMe result\n * @param query\n * @param theModel\n */\nexport function listShowMe(query: string, theModel: IMatch.IModels): Promise<MongoQ.IProcessedMongoAnswers> {\n  // Todo: preprocess query\n  // Show me FAct =>  url with CAT is FACT\n  //\n  return MongoQ.queryWithURI(query, theModel, []).then(\n    res => {\n      debuglog(() => 'got a query result' + JSON.stringify(res, undefined, 2));\n      // we find the \"best\" uri\n      var bestURI = undefined;\n      res.forEach((qr, index) => {\n        var domain = qr.domain;\n        if (!bestURI && qr.results.length && domain) {\n          var uriCategories = Model.getShowURICategoriesForDomain(theModel, domain);\n          var uriCategory = uriCategories[0];\n          // EXTEND: do some priorization and search for all\n          if (uriCategory &&\n              (( qr.columns.indexOf(uriCategory) >= 0)\n              || qr.auxcolumns.indexOf(uriCategory) >= 0))\n            {\n            //var colIndex = qr.columns.indexOf(showMeCategories[0]);\n            qr.results.forEach(res => {\n              debuglog(()=> 'result + ' + JSON.stringify(res));\n              if (!bestURI && res[uriCategory]) {\n                bestURI = res[uriCategory];\n              }\n            });\n          }\n        }\n      });\n      return Object.assign(res, { bestURI: bestURI });\n    }\n  );\n}\n"],"sourceRoot":"ABC"}