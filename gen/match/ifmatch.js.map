{"version":3,"sources":["/projects/nodejs/botbuilder/fdevstart/src/../src/match/ifmatch.ts"],"names":[],"mappings":";;AAEA,6CAAsC;AAEtC,IAAkB,gBAIjB;AAJD,WAAkB,gBAAgB;IAChC,6DAAW,CAAA;IACX,uDAAI,CAAA;IACJ,yDAAK,CAAA;AACP,CAAC,EAJiB,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAIjC;AAGY,QAAA,YAAY,GAAG,UAAU,CAAC;AAC1B,QAAA,UAAU,GAAG,QAAQ,CAAC;AACtB,QAAA,QAAQ,GAAG,MAAM,CAAC;AAGlB,QAAA,iBAAiB,GAAG,eAAe,CAAC;AACpC,QAAA,eAAe,GAAG,aAAa,CAAC;AAK5C,CAAC;AAQD,CAAC;AAaW,QAAA,cAAc,GAAG,CAAC,eAAe,EAAE,aAAa,EAAE,YAAY,EAAE,WAAW,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAoD5G,CAAC;AAoBG,CAAC;AAiEL,CAAC;AAIe,CAAC;AA2EjB,CAAC;AAaD,CAAC;AA4BF,IAAkB,cAGjB;AAHD,WAAkB,cAAc;IAC9B,2DAAQ,CAAA;IACR,mEAAY,CAAA;AACd,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B;AASD,2CAAsC;AAA7B,gCAAA,OAAO,CAAA;AAChB;;EAEE;AACF;;;;;;;;;;;;;;;;KAgBK;AAEQ,QAAA,YAAY,GAAG,qBAAO,CAAC,YAAY,CAAC;AAGjD,2DAA2D;AAC3D;;;;;;;;;;;;;;;;;;;;;;;;;EAyBE","file":"match/ifmatch.js","sourcesContent":["\n\nimport { IFModel } from 'mgnlq_model';\n\nexport const enum EnumResponseCode {\n  NOMATCH = 0,\n  EXEC,\n  QUERY\n}\n\n\nexport const CAT_CATEGORY = \"category\";\nexport const CAT_FILLER = \"filler\";\nexport const CAT_TOOL = \"tool\";\n\n\nexport const ERR_NO_KNOWN_WORD = \"NO_KNOWN_WORD\";\nexport const ERR_EMPTY_INPUT = \"EMPTY_INPUT\";\n\nexport interface IERError {\n  err_code : string,\n  text : string\n};\n\nexport interface IERErrorNO_KNOWN_WORD extends IERError{\n  context : {\n    token : string,\n    index: number,\n    tokens : string[]\n  }\n};\n\n\n\nexport interface IPromptDescription {\n  description: string,\n  type: string,\n  pattern: RegExp,\n  message: string,\n  default: string,\n  required: boolean\n}\n\nexport const aOperatorNames = [\"starting with\", \"ending with\", \"containing\", \"excluding\", \"having\", \"being\"];\nexport type OperatorName = \"starting with\" | \"ending with\" | \"containing\" | \"being\" | \"excluding\" | \"having\";\n\nexport interface IOperator {\n  operator : OperatorName,\n  code : string,\n  arity : number,\n  argcategory : [ string[] ]\n}\n\nexport type IRecord = { [key : string] : string\n};\n\n\nexport interface IWhatIsAnswer {\n  sentence: ISentence,\n  record : IRecord,\n  category : string,\n  result: string,\n  _ranking : number\n}\n\nexport type IRule = IFModel.IRule;\n\nexport type mRule = IFModel.mRule;\n\n\nexport interface IProcessedWhatIsAnswers extends IProcessed {\n  sentences? : ISentence[],\n  answers : IWhatIsAnswer[]\n}\n\n\n\nexport interface IProcessedWhatIsTupelAnswers extends IProcessed {\n  sentences? : ISentence[],\n  tupelanswers : Array<IWhatIsTupelAnswer>\n}\n\n\nexport interface IWhatIsTupelAnswer {\n  sentence: ISentence,\n  record : IRecord,\n  categories : string[],\n  result: string[],\n  _ranking : number\n}\n\n\nexport interface IMatchedSetRecord {\n  setId : string,\n  record : IRecord\n};\nexport type IMatchedSetRecords = IMatchedSetRecord[];\n/**\n * Map category -> value\n */\nexport type IMatchSet = { [key : string] : string};\n\nexport type EnumRuleType = IFModel.EnumRuleType;\n\n//export const enum EnumRuleType = IFModel.EnumRuleType;\n/*\nexport const  enum EnumRuleType {\n  WORD,\n  REGEXP\n}\n*/\n\nexport interface IToolSet {\n      set: string[],\n      response: string\n    };\n\nexport type IToolSets = {\n    [key: string]: IToolSet\n    };\n/**\n * @interface ITool\n *\n * var oTool = { 'name' : 'FLPD',\n *   'requires' : { 'systemId' : {}, 'client' :{}},\n *   'optional' : { 'catalog' : {}, 'group' :{}}\n * };\n*/\nexport interface ITool {\n  name: string,\n  requires: { [key: string]: Object },\n  optional?: { [key: string]: Object },\n  sets?: IToolSets\n}\n\nexport interface IToolMatchResult {\n  required: { [key: string]: IWord },\n  missing: { [key: string]: number },\n  optional?: { [key: string]: IWord },\n  spurious: { [key: string]: number },\n  toolmentioned: IWord[]\n}\n\nexport interface IPrompt {\n  text: string,\n  category: string\n}\n\nexport interface IToolMatch {\n  toolmatchresult: IToolMatchResult,\n  sentence: ISentence,\n  tool: ITool,\n  rank: number\n}\n\nexport interface IWord {\n  string: string,\n  matchedString: string,\n  category: string,\n  _ranking?: number,\n  levenmatch?: number,\n  reinforce?: number,\n  bitindex? : number,\n  rule? : IFModel.mRule\n}\n\nexport type ISentence = Array<IWord>;\n\n\nexport interface IntentRule {\n  type: EnumRuleType,\n  regexp: RegExp,\n  argsMap: { [key: string]: number }  // a map of regexp match group -> context key\n  // e.g. /([a-z0-9]{3,3})CLNT([\\d{3,3}])/\n  //      { 1 : \"systemId\", 2 : \"client\" }\n  follows?: context\n}\n\nexport interface IRange {\n  low: number, high: number,\n};\n\nexport interface IWordRange extends IRange\n{\n  rule? : mRule };\n/**\n * A rule matching a single string\n */\n\n//import { IErRule } from 'mgnlq_er'\n\n/*}\n\nexport interface mRule {\n  type: EnumRuleType,\n  word?: string,\n  lowercaseword? : string,\n  regexp?: RegExp,\n  matchedString?: string,\n  matchIndex?: number,\n  category: string,\n  bitindex : number,\n  range? :  IWordRange,\n  /* *\n   * only use an exact match\n   * /\n  exactOnly? : boolean,\n  _ranking?: number\n}\n*/\n\nexport interface IWordRules {\n  rules : Array<IFModel.mRule>,\n  bitindex: number\n}\nexport type SplitRules = IFModel.SplitRules;\n/*\nexport interface SplitRules {\n  allRules: Array<mRule>,\n  nonWordRules : Array<mRule>,\n  wordMap: { [key : string] : IWordRules },\n  wordCache :  { [key: string]: Array<ICategorizedString> }\n};\n*/\n\nexport interface ICategorizedString {\n  string: string,\n  matchedString: string,\n  category: string,\n  breakdown?: Array<any>\n  score?: number,\n  _ranking?: number,\n  levenmatch?: number  // a distance ranking\n}\n\nexport interface ICategorizedStringRanged extends ICategorizedString{\n  string: string,\n  matchedString: string,\n  category: string,\n  breakdown?: Array<any>\n  /**\n   * Length of the entry (for skipping following words)\n   */\n  score?: number,\n  span? : number,\n  rule : mRule,\n  _ranking?: number,\n  levenmatch?: number  // a distance ranking\n}\n\nexport interface IProcessed {\n  tokens : string[],\n  errors? : IERError[]\n}\n\nexport interface IProcessedSentences extends IProcessed {\n  tokens : string[],\n  errors? : any,\n  sentences : ISentence[]\n};\n\nexport type ICategoryFilter = { [key: string]: boolean };\n\n\nexport type IDomainCategoryFilter = {\n  domains : string[],\n  categorySet : { [key: string]: boolean }\n}\n\n\nexport interface IProcessedExtractedCategories extends IProcessed {\n  categories : string[],\n};\n\n\n\nexport type context = { [key: string]: string };\n\n/**\n * Defines the interface for an analysis\n * reponse\n */\nexport interface IResponse {\n  rating: number,\n  type: EnumResponseCode,\n  query: string,\n  context: { [key: string]: string },\n  text: string,\n  action: IAction,\n  prompts: {\n    [key: string]: {\n      text: string,\n      /**\n       * Follows the features of NPM prompts\n       */\n      description: IPromptDescription\n    };\n  }\n}\n\nexport const enum EnumActionType {\n  STARTURL,\n  STARTCMDLINE\n}\n\nexport interface IAction {\n  data: any,\n  type: EnumActionType,\n  pattern: string,\n  concrete: string\n}\n\nexport { IFModel } from 'mgnlq_model';\n/*\nexport { IModel = IFModel.IMdoIFModel.IModel } as IModel;\n*/\n/*\nexport interface IModel {\n    domain: string,\n    bitindex : number,\n    description? : string,\n    tool: ITool,\n    toolhidden?: boolean,\n    synonyms?: { [key: string]: string[] },\n    categoryDescribed :  { name : string,\n        description? : string,\n        key? : string }[],\n    category: string[],\n    columns? : string[],\n    wordindex: string[],\n    exactmatch? : string[],\n    hidden: string[]\n}; */\n\nexport const EnumRuleType = IFModel.EnumRuleType;\nexport type IModels = IFModel.IModels;\n\n//export { IFModel.IModels as IModels } from 'mgnlq_model';\n/*\n\nexport interface IModels {\n    full : {\n      domain : { [key : string] : {\n          description: string,\n          bitindex : number,\n          categories : { [key : string] : ICategoryDesc }\n        }\n      }\n    },\n    rawModels : { [key : string] : IModel};\n    domains: string[],\n    tools: ITool[],\n    category: string[],\n    operators : { [key: string] : IOperator },\n    mRules: mRule[],\n    rules : SplitRules,\n    records: any[]\n    seenRules?: { [key: string]: mRule[] },\n    meta : {\n        // entity -> relation -> target\n        t3 : { [key: string] : { [key : string] : any }}\n    }\n}\n*/"],"sourceRoot":"ABC"}